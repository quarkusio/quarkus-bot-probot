module.exports = affectMilestone

async function affectMilestone (context) {
  const dryRun = process.env.DRY_RUN;
  const pullRequest = context.payload.pull_request
  const targetBranch = context.payload.pull_request.base.ref

  if (!pullRequest.merged && !dryRun) {
    return
  }
  if (targetBranch != 'master' && targetBranch != 'main') {
    return
  }

  const masterMilestone = await getMasterMilestone(context)
  if (masterMilestone == null) {
    context.log.error("Unable to find the master milestone");
    return
  }

  const currentMilestone = pullRequest.milestone

  if (!currentMilestone && !hasAreaInfraLabel(pullRequest)) {
    if (!dryRun) {
      const issueUpdate = context.issue({ milestone: masterMilestone.number })
      await context.github.issues.update(issueUpdate);
    } else {
      context.log.warn("Pull request #" + pullRequest.number + " - Affect milestone: " + masterMilestone.title)
    }
  }

  const resolvedIssues = getResolvedIssues(context, pullRequest)
  const alreadyAffectedIssues = []
  for (const resolvedIssueNumber of resolvedIssues) {
    const resolvedIssue = await context.github.issues.get(context.repo({ issue_number: resolvedIssueNumber }))

    if (resolvedIssue.data.milestone && (resolvedIssue.data.milestone.number != masterMilestone.number)) {
      alreadyAffectedIssues.push(resolvedIssueNumber)
    } else {
      if (!dryRun) {
        const issueUpdate = context.repo({ issue_number: resolvedIssueNumber, milestone: masterMilestone.number })
        await context.github.issues.update(issueUpdate);
      } else {
        context.log.warn("Issue #" + resolvedIssueNumber + " - Affect milestone: " + masterMilestone.title)
      }
    }
  }

  let commentBody = ''
  if (currentMilestone && (currentMilestone.number != masterMilestone.number)) {
    commentBody += "* The pull request itself\n"
  }
  for (const alreadyAffectedIssue of alreadyAffectedIssues) {
    commentBody += "* Issue #" + alreadyAffectedIssue + "\n"
  }
  if (commentBody) {
    commentBody = "Milestone is already set for some of the items:\n\n" + commentBody
    commentBody += "\nWe haven't automatically updated the milestones for these items.\n"
    commentBody += "\n> This message is automatically generated by a bot."

    if (!dryRun) {
      const issueComment = context.issue({ body: commentBody })
      await context.github.issues.createComment(issueComment)
    } else {
      context.log.warn("Pull request #" + pullRequest.number + " - Add comment " + commentBody)
    }
  }
}

async function getMasterMilestone(context) {
  const milestoneQuery = context.repo({ state: 'open' });
  const milestones = await context.github.issues.listMilestones(milestoneQuery)
  for (const milestone of milestones.data) {
    if (milestone.title.endsWith('- master')) {
      return milestone;
    }
  }
  return null;
}

function getResolvedIssues(context, pullRequest) {
  if (pullRequest.body == null) {
    return []
  }

  const owner = context.repo().owner
  const repo = context.repo().repo

  const issueExtractionRegexp = new RegExp("\\b(?:(?:fix(?:e[sd])?|(?:(?:resolve|close)[sd]?))):?\\s+(?:https?:\\/\\/github.com\\/" + owner + "\\/" + repo + "\\/issues\\/|#)(\\d+)", "gsmi")
  const issueMatches = pullRequest.body.matchAll(issueExtractionRegexp)

  const resolvedIssues = []
  for (const issueMatch of issueMatches) {
    resolvedIssues.push(issueMatch[1]);
  }

  return resolvedIssues;
}

function hasAreaInfraLabel (pullRequest) {
  for (const label of pullRequest.labels) {
    if (label.name == 'area/infra') {
      return true;
    }
  }
  return false;
}